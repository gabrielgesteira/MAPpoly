% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pairwise_haplotype_rf.R
\name{est_rf_marker_blocks}
\alias{est_rf_marker_blocks}
\title{Two-point analysis for marker blocks}
\usage{
est_rf_marker_blocks(block1, block2, ph1 = "best", ph2 = "best", M,
  max.inc = 0, block1.tail = NULL, tol = 0.01)
}
\arguments{
\item{block1}{a block of phased SNPs contained in a object of
class\code{\link[mappoly]{mappoly.map}}.}

\item{block2}{a block of phased SNPs contained in a object of
class\code{\link[mappoly]{mappoly.map}}.}

\item{ph1}{an integer indicating the position of
the linkage phase configuration for the first marker block.
 If \code{NULL}, it uses the position with maximum likelihood.}

\item{ph2}{an integer indicating the position of
the linkage phase configuration for the second marker block.
If \code{NULL}, it uses the position with maximum likelihood.}

\item{M}{a matrix containg the number of homologous chromosomes that
share alleic variations between the SNPs contained in the phased
marker blocks. The rows represent SNPs in the first marker block
and the columns represent SNPs in the second marker block. This
matrix can be obtained using the function class\code{\link[mappoly]{mat_share}}}

\item{max.inc}{the maximum inconsitency acceptable when filtering the
linkage phase configuration based on two-point information. 
Pairs with higher numbers will not be taken in to account in 
the filtering process.}

\item{block1.tail}{the number of SNPs that should be used in the first
phased marker block. If \code{NULL} (default) uses all SNPs}
}
\value{
an object of class \code{mappoly.mrkblock.est.twopt}
}
\description{
Performs the two-point pairwise analysis between two blcoks of phased SNPs.
}
\details{
When uThe \code{max.inc} argument
}
\examples{
  \dontrun{
  data(hexafake)
  mrk.subset<-make_seq_mappoly(hexafake, 21:30)
  red.mrk<-elim_redundant(mrk.subset)
  unique.mrks<-make_seq_mappoly(red.mrk)
  counts.web<-cache_counts_twopt(unique.mrks, get.from.web = TRUE)
  subset.pairs<-est_pairwise_rf(input.seq = unique.mrks,
                                count.cache = counts.web)
  subset.map <- est_rf_hmm_sequential(input.seq = unique.mrks,
                                      thres.twopt = 5,
                                      thres.hmm = 10,
                                      extend.tail = 10,
                                      tol = 0.1,
                                      tol.final = 10e-3,
                                      twopt = subset.pairs,
                                      verbose = TRUE,
                                      high.prec = FALSE)
                                      
  s1 <- make_seq_mappoly(hexafake, subset.map$maps[[1]]$seq.num[1:5])                                     
  map1 <- get_submap(subset.map, 1:5)
  
  s2 <- make_seq_mappoly(hexafake, subset.map$maps[[1]]$seq.num[6:10])                                     
  map2 <- get_submap(subset.map, 6:10)
  
   twopt.sub <- make_pairs_mappoly(subset.pairs, 
                                   make_seq_mappoly(hexafake, 
                                                    c(map1$maps[[1]]$seq.num, 
                                                      map2$maps[[1]]$seq.num)))           
   M<-mat_share(map1,
                map2,
                twopt.sub,
                count.cache = counts.web,
                thres = 3)
   M
   rf_map1_map2<-est_twopt_hap(block1 = map1,
                               block2 = map2,
                               ph1 = "best",
                               ph2 = "best",
                               M = M,
                               max.inc = 0,
                               block1.tail = NULL,
                               tol = 0.01)
                               
   new.map<-subset.map
   new.map$maps[[1]]$seq.ph <- list(P = c(rf_map1_map2$phM1[[1]]$config.to.test[[1]]$P,
                                          rf_map1_map2$phM2[[1]]$config.to.test[[1]]$P),
                                    Q = c(rf_map1_map2$phM1[[1]]$config.to.test[[1]]$Q,
                                          rf_map1_map2$phM2[[1]]$config.to.test[[1]]$Q))
  new.map$maps[[1]]$seq.rf[25]<-rf_map1_map2$rf.stats[1, "rf"]
  plot_compare_haplotypes(m = 6, 
                          hom.allele.p1 = subset.map$maps[[1]]$seq.ph$P, 
                          hom.allele.p2 = new.map$maps[[1]]$seq.ph$P, 
                          hom.allele.q1 = subset.map$maps[[1]]$seq.ph$Q,
                          hom.allele.q2 = new.map$maps[[1]]$seq.ph$Q)
   }
}
\references{

}
\author{
Marcelo Mollinari, \email{mmollin@ncsu.edu}
}
